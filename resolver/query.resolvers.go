package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"crypto/subtle"
	"kilogram-api/model"
	"kilogram-api/server"
)

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	return GetCurrentUserFrom(ctx), nil
}

// SignIn is the resolver for the signIn field.
func (r *queryResolver) SignIn(ctx context.Context, login string, password string) (*string, error) {
	r.UsersMu.RLock()
	user, ok := r.UsersByLogin[login]
	r.UsersMu.RUnlock()

	if !ok {
		return nil, ErrNotAuthorized
	}

	if subtle.ConstantTimeCompare([]byte(user.Password), []byte(password)) == 0 {
		return nil, ErrNotAuthorized
	}

	sign, err := model.SignUser(login, password)

	if err != nil {
		return nil, ErrNotAuthorized
	}

	return &sign, nil
}

// Chat is the resolver for the chat field.
func (r *queryResolver) Chat(ctx context.Context, id string) (*model.Chat, error) {
	r.ChatsMu.RLock()
	defer r.ChatsMu.RUnlock()

	chat, ok := r.ChatsByID[id]

	if !ok {
		return nil, ErrChatDoesnotExists
	}

	if chat.ID == model.SpamChatID {
		return chat, nil
	}

	user := GetCurrentUserFrom(ctx)

	if _, ok := chat.AllMembersByLogin[user.Login]; ok {
		return chat, nil
	}

	return nil, ErrMembership
}

// Chats is the resolver for the chats field.
func (r *queryResolver) Chats(ctx context.Context, offset *int, first *int) ([]*model.Chat, error) {
	begin := *offset
	count := *first

	user := GetCurrentUserFrom(ctx)

	r.ChatsMu.RLock()
	defer r.ChatsMu.RUnlock()

	chats := r.Resolver.Chats

	if begin >= len(chats) {
		return nil, nil
	}

	if begin < 0 {
		count += begin
		begin = 0
	}

	if count <= 0 {
		return nil, nil
	}

	if len(chats) < begin+count {
		count = len(chats) - begin
	}

	chats = chats[begin:]

	result := make([]*model.Chat, 0, count)

	for i := 0; len(result) < count && i < len(chats); i++ {
		if chats[i].ID == model.SpamChatID {
			result = append(result, chats[i])

			continue
		}

		if user == nil {
			continue
		}

		if _, ok := chats[i].AllMembersByLogin[user.Login]; ok {
			result = append(result, chats[i])

			continue
		}
	}

	return result, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, login string) (*model.User, error) {
	r.UsersMu.RLock()
	defer r.UsersMu.RUnlock()

	user, ok := r.UsersByLogin[login]

	if !ok {
		return nil, ErrUserDoesnotExists
	}

	return user, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, offset *int, first *int) ([]*model.User, error) {
	begin := *offset
	count := *first

	r.UsersMu.RLock()
	defer r.UsersMu.RUnlock()

	users := r.Resolver.Users

	if begin >= len(users) {
		return nil, nil
	}

	if begin < 0 {
		count += begin
		begin = 0
	}

	if count < 0 {
		return nil, nil
	}

	if len(users) < begin+count {
		count = len(users) - begin
	}

	return users[begin : begin+count], nil
}

// Query returns server.QueryResolver implementation.
func (r *Resolver) Query() server.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
